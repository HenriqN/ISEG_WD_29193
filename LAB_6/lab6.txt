- Can you describe how user authentication and authorization is implemented in each project?  
Project 1: 
Upon registration, the user's username, email, and password are stored in a database. The password is encrypted using SHA256 and the generate_password_hash function from the werkzeug.security module to ensure its security. During the login process, the user's entered username is queried against the database to determine if it exists. If it does, the system retrieves the previously hashed password and compares it to the entered password using the check_password_hash function. If the passwords match, a session is created with the user's username and a logged_in flag set to True, which allows the user access to the application. The @login_required decorator is used in routes that require authentication, such as the user's profile page. If an unauthenticated user attempts to access a protected route, they are redirected to the login page.

Project 2:
When a user logs in with their email and password, the code queries the database to validate their credentials. If the credentials are correct, the user's ID is saved in the "user_id" session variable. The session allows the server to recognise the user on subsequent requests, enabling authorisation. For instance, when a user tries to access their profile page, the server verifies whether the "user_id" session variable exists. If it does, the server retrieves the user's data and posts from the database and displays them on the profile page. If "user_id" is not in the session, the server redirects the user to the login page. The server also uses authorisation when a user submits a post. It first checks if "user_id" is in the session, and if it is, the post is saved to the database with the user's ID. If "user_id" is not present in the session, the user is redirected to the login page.


- Can you describe how user posts and comments are implemented in Project 1?  
Posts:
Posts are defined with the following fields: id, title, content, created_date, updated_date, and author_id. The author_id field is a foreign key that references the User model, indicating which user created the post. Several views are defined to handle different actions related to posts, such as post_list to display all posts, post_detail to show a single post, post_create to create a new post, post_update to update an existing post, and post_delete to delete a post from the database. PostForm is used to validate and process user input when creating or updating a post. Overall, these views interact with the database using Post.objects to query and manipulate data.

Comments:
Comments contains the following fields: id, text, created_date, updated_date, author_id, and post_id. A view named comment_create is created to handle the creation of new comments, which utilizes CommentForm to validate user input and create a new Comment object with the validated data. The post_detail view is updated to display comments associated with a post, and retrieves them from the database using Comment.objects.filter(post_id=post_id). A comment_update view is defined to handle updating an existing comment, and uses CommentForm to validate and process user input. Similarly, the comment_delete view is created to handle deleting existing comments.


- Can you describe how the search feature is implemented in project 1?  
The search feature in the code is implemented using a GET request to the /search route. When a user types a search query in the search bar and clicks the "search" button, a GET request is sent to the server with the search query as a parameter in the URL. The server's route handler retrieves the search query from the request parameters and performs a query to search for posts and comments that contain the search query in their title, body, or author username. The search results are then displayed using the search.html template. The template shows a list of posts and comments that match the search query, along with their title, body, author, and a link to view the full post or comment. If there are no search results, the template displays a message indicating that no results were found. While this search feature is relatively simple, more advanced search technologies may be needed for larger and more complex applications.


- Can you describe how user photos are uploaded on project 2?  
User photos are uploaded during user registration through the /register route. When the user submits the registration form containing their personal information and image, the form data is sent to the /register route where the image file is retrieved using the Flask request module. The file name is secured to prevent malicious names from being used, and the image is saved to the server using the save() method of the FileStorage object. The path to where the file should be saved is specified, and the file is saved to the "static" folder. Finally, the user's information, including the file name, is stored in the database using the register_user() function in the models module.


- Can you describe how the MVC architecture was implemented in project 2?  
The code follows the Model-View-Controller (MVC) architecture, where the models.py file deals with the database, the views.py file renders HTML templates for user interfaces, and the controllers.py file contains Flask routes that define the endpoints for the web application and interact with the models to query and update the database. This separation of concerns ensures that the code is organised and modular, where the model handles data and database interactions, the view displays data to the user, and the controller handles user input and application logic.